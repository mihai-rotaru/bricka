#!/usr/bin/env python
# encoding: utf-8

"""
A waf tool for **htmlcompressor**
(http://code.google.com/p/htmlcompressor)
"""

import os
from waflib.Configure import conf
from waflib.Task import Task, compile_fun
from waflib.Node import split_path
from waflib.TaskGen import extension, feature, after, after_method
from waflib import Utils, Errors

import utils

class compress_html_base( Task ):
    color = 'PINK'
    no_output_fun = compile_fun( 'java -jar ${htmlcompressor_abspath} ${htmlcompressor_options} ${SRC} -o ${SRC}' )[0]
    w_output_fun  = compile_fun( 'java -jar ${htmlcompressor_abspath} ${htmlcompressor_options} ${SRC} -o ${TGT}' )[0]

    def run( self ):
        if not self.outputs:
            return compress_html_base.no_output_fun( self )
        else:        
            return compress_html_base.w_output_fun( self )

class compress_html( compress_html_base ):
    after = [ 'update_minifier' ]
    def run( self ):
        compress_html_base.run( self )
        if( self.env[ 'closure_compiler' ] ):
            #os.remove( self.inputs[0].abspath() )
            pass

@feature( 'html' )
@after_method( 'generate_minification_tasks' )
def generate_html_compression_tasks( self ):
    for node in self.source_list:
        # check if the file already exists in the build directory. If it does, then
        # it means it was generated by another tool - like minify and/or concat. If
        # it doesn't exist, compress the file in the source directory and copy it to
        # the build directory.
        src = self.bld.path.find_resource( node.nice_path() )
        if src:
            self.create_task( 'compress_html', src, None )
        else:
            self.create_task( 'compress_html', node, node.get_bld() )

def configure( conf ):
    conf.find_program( 'java' )
    conf.env['htmlcompressor_abspath'] = os.path.abspath( conf.find_file( 'htmlcompressor-1.5.3.jar', ['.','./tools' ] ) )
